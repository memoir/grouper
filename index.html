<!DOCTYPE html>
<html lang="de">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Grouper</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      text-align: center;
    }

    .container {
      display: flex;
      justify-content: space-around;
      align-items: flex-start;
      flex-wrap: nowrap;
      margin-top: 20px;
    }

    .dropzone {
      min-width: 120px;
      min-height: 100px;
      border: 2px dashed #ccc;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      position: relative;
      padding: 20px;
      margin: 10px;
      background-color: #f9f9f9;
      transition: height 0.3s ease-in-out;
    }

    /* New table styles for slot container */
    .slot-table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 10px;
    }

    .slot-row {
      height: 45px;
      border: 1px solid #ccc;
      background-color: #f0f0f0;
      position: relative;
    }

    .slot-row:hover {
      background-color: #e8e8e8;
    }

    .slot-row.filled {
      background-color: transparent;
    }

    .slot-row.hover {
      background-color: #e8f4e8;
      border: 1px solid #9F6A15;
    }

    /* Remove old slot container styles */
    .slot-container {
      display: none;
    }

    .slot {
      display: none;
    }

    .draggable-container {
      display: flex;
      justify-content: center;
      align-items: center;
      flex-wrap: wrap;
      width: 80%;
      margin: 40px auto;
      padding: 20px;
      border: 2px solid #9F6A15;
      background-color: #f9f9f9;
      border-radius: 10px;
    }

    .draggable {
      width: 100px;
      height: 40px;
      background-color: #9F6A15;
      color: white;
      text-align: center;
      line-height: 40px;
      cursor: grab;
      margin: 10px;
      border-radius: 4px;
      z-index: 10;
    }

    /* Draggable items inside table rows */
    .slot-row .draggable {
      margin: 2px auto;
      width: 95%;
    }

    .dropzone.over {
      background-color: #f0f0f0;
    }

    .counter {
      position: absolute;
      top: 5px;
      right: 5px;
      font-size: 14px;
      color: #555;
    }

    .zone-title {
      position: absolute;
      top: -25px;
      font-size: 16px;
      font-weight: bold;
      cursor: pointer;
    }

    .zone-title:hover::after {
      content: " ✎";
      font-size: 14px;
      color: #888;
    }

    .title-edit {
      position: absolute;
      top: -25px;
      left: 0;
      font-size: 16px;
      font-weight: bold;
      border: 1px solid #ccc;
      padding: 2px;
      z-index: 10;
    }

    .full {
      background-color: #ffcccc;
      border-color: #ff0000;
    }

    .group-controls {
      margin-bottom: 10px;
      text-align: center;
    }

    .delete-group-btn {
      position: absolute;
      top: -25px;
      right: 0;
      background: #ff6666;
      color: white;
      border: none;
      border-radius: 4px;
      padding: 2px 8px;
      cursor: pointer;
      font-size: 14px;
    }

    .delete-group-btn:hover {
      background: #cc0000;
    }

    .info-green {
      color: #388e3c !important;
    }

    .info-red {
      color: #d32f2f !important;
    }

    .info-blue {
      color: #1976d2 !important;
    }

    footer {
      margin-top: 40px;
      padding: 15px 0;
      font-size: 12px;
      color: #777;
      border-top: 1px solid #eee;
      text-align: center;
    }

    /* Logo styles */
    .logo {
      position: absolute;
      top: 20px;
      right: 20px;
      width: 130px;
      height: 130px;
      z-index: 5;
    }

    /* Adjust main header to accommodate logo */
    h1 {
      margin-right: 150px;
      color: #9F6A15;
    }
  </style>
</head>

<body>
  <!-- Logo in the upper right corner -->
  <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIIAAACCCAYAAACKAxD9AAAEtWlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4KPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iWE1QIENvcmUgNS41LjAiPgogPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4KICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIgogICAgeG1sbnM6dGlmZj0iaHR0cDovL25zLmFkb2JlLmNvbS90aWZmLzEuMC8iCiAgICB4bWxuczpleGlmPSJodHRwOi8vbnMuYWRvYmUuY29tL2V4aWYvMS4wLyIKICAgIHhtbG5zOnBob3Rvc2hvcD0iaHR0cDovL25zLmFkb2JlLmNvbS9waG90b3Nob3AvMS4wLyIKICAgIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIKICAgIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIgogICAgeG1sbnM6c3RFdnQ9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZUV2ZW50IyIKICAgdGlmZjpJbWFnZUxlbmd0aD0iMTMwIgogICB0aWZmOkltYWdlV2lkdGg9IjEzMCIKICAgdGlmZjpSZXNvbHV0aW9uVW5pdD0iMiIKICAgdGlmZjpYUmVzb2x1dGlvbj0iNzIvMSIKICAgdGlmZjpZUmVzb2x1dGlvbj0iNzIvMSIKICAgZXhpZjpQaXhlbFhEaW1lbnNpb249IjEzMCIKICAgZXhpZjpQaXhlbFlEaW1lbnNpb249IjEzMCIKICAgZXhpZjpDb2xvclNwYWNlPSIxIgogICBwaG90b3Nob3A6Q29sb3JNb2RlPSIzIgogICBwaG90b3Nob3A6SUNDUHJvZmlsZT0ic1JHQiBJRUM2MTk2Ni0yLjEiCiAgIHhtcDpNb2RpZnlEYXRlPSIyMDI1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" alt="Grouper Logo" class="logo">

  <h1>Grouper</h1>

  <div class="group-controls">
    <button id="btn_add_group">Gruppe hinzufügen</button>
    <span id="group_space_info" style="margin-left:10px; font-size:14px; color:#555; font-weight:bold;"></span>
  </div>
  
  <div style="margin-top: 10px; margin-bottom: 10px;">
    <button id="btn_random_distribute">Zufällig auf bestehende Gruppen verteilen</button>
    <input type="number" id="group_count" min="1" value="2" style="width: 60px; padding: 5px;">
    <button id="btn_create_equal_groups">Zufällig auf n Gruppen verteilen</button>
    <button id="btn_create_size_groups">Zufällig auf Gruppen der Größe n verteilen</button>
  </div>

  <div class="container" id="container">
    <!-- Felder werden hier dynamisch hinzugefügt -->
  </div>

  <div class="draggable-container" id="draggableContainer">
    <!-- Draggable Items werden hier dynamisch hinzugefügt -->
  </div>
  <div style="margin: 20px 0;">
    <input type="text" id="new_item_name" placeholder="Neues Element" style="padding:5px; font-size:14px;">
    <button id="btn_add_item">Element hinzufügen</button>
  </div>
  <div>
  </div>
  <div>
    <button id="btn_reset">Zurücksetzen</button>
    <button id="btn_download">Speichern</button>
    <input type="file" id="configFile" style="display:none" accept="application/json">
    <button id="btn_load">Laden</button>
    <button id="btn_download_text">Als Text speichern</button>
  </div>

  <footer>
    © Mehmet Aydin
  </footer>

  <script>
    // ---------- Konfiguration und Logik für die Gruppeneinteilung ----------
    let fieldConfig = [
      // Start with no groups
    ];

    let items = [
      // Start with no items
    ];

    // Helper to update the group space info
    function updateGroupSpaceInfo() {
      const totalMax = fieldConfig.reduce((sum, f) => sum + f.maxItems, 0);
      const diff = items.length - totalMax;
      const info = document.getElementById('group_space_info');
      info.classList.remove('info-green', 'info-red', 'info-blue');
      if (diff > 0) {
        info.textContent = `Noch ${diff} Element${diff === 1 ? '' : 'e'} ohne Platz.`;
        info.classList.add('info-red');
      } else if (diff === 0) {
        info.textContent = 'Alle Elemente haben einen Platz.';
        info.classList.add('info-green');
      } else {
        info.textContent = `Es gibt ${-diff} ${-diff !== 1 ? '' : 'Platz'}${-diff === 1 ? '' : 'Plätze'} mehr als Elemente.`;
        info.classList.add('info-blue');
      }
    }

    // Hilfsfunktion: Dropzone erstellen
    function createDropzone(field) {
      const dropzone = document.createElement('div');
      dropzone.classList.add('dropzone');
      dropzone.id = field.id;
      dropzone.setAttribute('data-max-items', field.maxItems);
      dropzone.setAttribute('data-current-items', 0);

      // Title with editable functionality
      const title = document.createElement('div');
      title.classList.add('zone-title');
      title.textContent = field.name;
      title.addEventListener('click', function() {
        // Create edit input
        const input = document.createElement('input');
        input.type = 'text';
        input.className = 'title-edit';
        input.value = title.textContent;
        input.style.width = Math.max(100, title.offsetWidth + 20) + 'px';
        
        // Handle saving on enter or blur
        function saveTitle() {
          const newTitle = input.value.trim();
          if (newTitle) {
            title.textContent = newTitle;
            // Update in fieldConfig
            const groupConfig = fieldConfig.find(f => f.id === field.id);
            if (groupConfig) {
              groupConfig.name = newTitle;
            }
          }
          if (input.parentNode) {
            input.parentNode.removeChild(input);
          }
          title.style.display = 'block';
        }
        
        input.addEventListener('keydown', function(e) {
          if (e.key === 'Enter') {
            e.preventDefault();
            saveTitle();
          } else if (e.key === 'Escape') {
            if (input.parentNode) {
              input.parentNode.removeChild(input);
            }
            title.style.display = 'block';
          }
        });
        
        input.addEventListener('blur', saveTitle);
        
        // Add input and hide title
        dropzone.insertBefore(input, title);
        title.style.display = 'none';
        input.focus();
        input.select();
      });
      dropzone.appendChild(title);

      // Delete button
      const btnDelete = document.createElement('button');
      btnDelete.textContent = '✕';
      btnDelete.type = 'button';
      btnDelete.className = 'delete-group-btn';
      btnDelete.title = 'Gruppe löschen';
      btnDelete.addEventListener('click', function () {
        // Move all items in this group back to unassigned
        Array.from(dropzone.querySelectorAll('.draggable')).forEach(item => {
          document.getElementById('draggableContainer').appendChild(item);
        });
        // Remove from fieldConfig
        fieldConfig = fieldConfig.filter(f => f.id !== field.id);
        // Remove from DOM
        dropzone.remove();
        updateGroupSpaceInfo();
      });
      dropzone.appendChild(btnDelete);

      // Size control buttons
      const sizeControls = document.createElement('div');
      sizeControls.style.marginBottom = '5px';

      const btnMinus = document.createElement('button');
      btnMinus.textContent = '–';
      btnMinus.type = 'button';
      btnMinus.style.marginRight = '2px';

      const btnPlus = document.createElement('button');
      btnPlus.textContent = '+';
      btnPlus.type = 'button';

      sizeControls.appendChild(btnMinus);
      sizeControls.appendChild(btnPlus);
      dropzone.appendChild(sizeControls);

      // Counter
      const counter = document.createElement('span');
      counter.classList.add('counter');
      counter.textContent = `0 / ${field.maxItems}`;
      dropzone.appendChild(counter);

      // Table for slots instead of slot container
      const slotTable = document.createElement('table');
      slotTable.classList.add('slot-table');
      
      // Create rows for each slot
      for (let i = 0; i < field.maxItems; i++) {
        const row = document.createElement('tr');
        row.classList.add('slot-row');
        row.dataset.slotIndex = i;
        row.dataset.empty = 'true';
        
        const cell = document.createElement('td');
        // Remove text from empty slots
        cell.textContent = '';
        
        row.appendChild(cell);
        slotTable.appendChild(row);
        
        // Add drop events to each row
        row.addEventListener('dragover', (e) => {
          e.preventDefault();
          if (row.dataset.empty === 'true') {
            row.classList.add('hover');
          }
        });
        
        row.addEventListener('dragleave', () => {
          row.classList.remove('hover');
        });
        
        row.addEventListener('drop', (e) => {
          e.preventDefault();
          const draggingItem = document.querySelector('.dragging');
          if (!draggingItem) return;
          
          const sourceZone = draggingItem.closest('.dropzone');
          const sourceRow = draggingItem.parentElement;
          
          // Only process the drop if the row is empty
          if (row.dataset.empty === 'true') {
            // Remove hover effect
            row.classList.remove('hover');
            
            // Clear row text
            row.innerHTML = '';
            
            // Mark the row as filled
            row.dataset.empty = 'false';
            row.classList.add('filled');
            
            // Move the item to this row
            row.appendChild(draggingItem);
            
            // Update counters
            if (sourceZone && sourceZone !== dropzone) {
              const sourceItems = parseInt(sourceZone.getAttribute('data-current-items'));
              sourceZone.setAttribute('data-current-items', sourceItems - 1);
              updateCounter(sourceZone);
              
              // Update source row
              if (sourceRow && sourceRow.classList.contains('slot-row')) {
                sourceRow.innerHTML = `<td></td>`;  // Empty cell with no text
                sourceRow.dataset.empty = 'true';
                sourceRow.classList.remove('filled');
              }
            } else if (sourceRow && sourceRow.classList.contains('slot-row') && sourceRow !== row) {
              sourceRow.innerHTML = `<td></td>`;  // Empty cell with no text
              sourceRow.dataset.empty = 'true';
              sourceRow.classList.remove('filled');
            }
            
            // Update target zone counter
            const currentItems = parseInt(dropzone.getAttribute('data-current-items')) + 1;
            dropzone.setAttribute('data-current-items', currentItems);
            updateCounter(dropzone);
          }
        });
      }
      
      dropzone.appendChild(slotTable);

      // Size controls logic
      btnPlus.addEventListener('click', () => {
        let maxItems = parseInt(dropzone.getAttribute('data-max-items'));
        // Find this group in fieldConfig and update its maxItems
        const group = fieldConfig.find(f => f.id === field.id);
        if (!group) return;
        
        // Allow increasing group size without restriction
        maxItems++;
        dropzone.setAttribute('data-max-items', maxItems);
        group.maxItems = maxItems;

        // Add a new row to the table
        const slotTable = dropzone.querySelector('.slot-table');
        const newRow = document.createElement('tr');
        newRow.classList.add('slot-row');
        newRow.dataset.slotIndex = maxItems - 1;
        newRow.dataset.empty = 'true';
        
        const cell = document.createElement('td');
        // Remove text from empty slot
        cell.textContent = '';
        
        newRow.appendChild(cell);
        slotTable.appendChild(newRow);
        
        // Add drop events to the new row
        newRow.addEventListener('dragover', (e) => {
          e.preventDefault();
          if (newRow.dataset.empty === 'true') {
            newRow.classList.add('hover');
          }
        });
        
        newRow.addEventListener('dragleave', () => {
          newRow.classList.remove('hover');
        });
        
        newRow.addEventListener('drop', (e) => {
          e.preventDefault();
          const draggingItem = document.querySelector('.dragging');
          if (!draggingItem) return;
          
          const sourceZone = draggingItem.closest('.dropzone');
          const sourceRow = draggingItem.parentElement;
          
          // Only process the drop if the row is empty
          if (newRow.dataset.empty === 'true') {
            // Remove hover effect
            newRow.classList.remove('hover');
            
            // Clear row text
            newRow.innerHTML = '';
            
            // Mark the row as filled
            newRow.dataset.empty = 'false';
            newRow.classList.add('filled');
            
            // Move the item to this row
            newRow.appendChild(draggingItem);
            
            // Update counters
            if (sourceZone && sourceZone !== dropzone) {
              const sourceItems = parseInt(sourceZone.getAttribute('data-current-items'));
              sourceZone.setAttribute('data-current-items', sourceItems - 1);
              updateCounter(sourceZone);
              
              // Update source row
              if (sourceRow && sourceRow.classList.contains('slot-row')) {
                sourceRow.innerHTML = `<td></td>`;  // Empty cell with no text
                sourceRow.dataset.empty = 'true';
                sourceRow.classList.remove('filled');
              }
            } else if (sourceRow && sourceRow.classList.contains('slot-row') && sourceRow !== newRow) {
              sourceRow.innerHTML = `<td></td>`;  // Empty cell with no text
              sourceRow.dataset.empty = 'true';
              sourceRow.classList.remove('filled');
            }
            
            // Update target zone counter
            const currentItems = parseInt(dropzone.getAttribute('data-current-items')) + 1;
            dropzone.setAttribute('data-current-items', currentItems);
            updateCounter(dropzone);
          }
        });

        updateCounter(dropzone);
        updateGroupSpaceInfo();
        adjustGroupHeight(dropzone);
      });

      btnMinus.addEventListener('click', () => {
        let maxItems = parseInt(dropzone.getAttribute('data-max-items'));
        let currentItems = parseInt(dropzone.getAttribute('data-current-items'));
        if (maxItems > 1 && maxItems > currentItems) {
          // Check if the last row contains an item
          const slotTable = dropzone.querySelector('.slot-table');
          const lastRow = slotTable.lastElementChild;
          
          if (lastRow && lastRow.dataset.empty === 'false') {
            // Move the item to unassigned
            const item = lastRow.querySelector('.draggable');
            if (item) {
              document.getElementById('draggableContainer').appendChild(item);
              
              // Adjust the count of items in the group
              const currentItems = parseInt(dropzone.getAttribute('data-current-items'));
              dropzone.setAttribute('data-current-items', currentItems - 1);
            }
          }
          
          // Remove the last row
          if (slotTable.lastElementChild) {
            slotTable.removeChild(slotTable.lastElementChild);
          }
          
          maxItems--;
          dropzone.setAttribute('data-max-items', maxItems);
          // Update fieldConfig for this group
          const group = fieldConfig.find(f => f.id === field.id);
          if (group) group.maxItems = maxItems;

          updateCounter(dropzone);
          updateGroupSpaceInfo();
          adjustGroupHeight(dropzone);
        }
      });

      // Drag/drop logic for dropzone container
      dropzone.addEventListener('dragover', (e) => {
        e.preventDefault();
      });

      dropzone.addEventListener('drop', (e) => {
        e.preventDefault();
        // Prevent direct drops on the container (rows should handle drops)
        // This is just a fallback
        const draggingItem = document.querySelector('.dragging');
        if (!draggingItem) return;
        
        // Find the first empty row
        const emptyRow = dropzone.querySelector('.slot-row[data-empty="true"]');
        if (emptyRow) {
          // Simulate a drop on the row
          const dropEvent = new Event('drop');
          emptyRow.dispatchEvent(dropEvent);
        }
      });

      return dropzone;
    }

    // Function to adjust the height of a group based on its table rows
    function adjustGroupHeight(group) {
      const headerHeight = 60; // Reduced height for controls, title, etc.
      const table = group.querySelector('.slot-table');
      if (!table) return;
      
      const rows = table.querySelectorAll('.slot-row');
      if (rows.length === 0) return;
      
      const rowHeight = 45; // Height per row
      
      // Calculate height based on number of rows only
      const tableHeight = rows.length * rowHeight;
      
      // Calculate the minimum height needed with less padding
      group.style.height = (headerHeight + tableHeight + 10) + 'px'; // Reduced padding from 30px to 10px
    }

    // Function to adjust all groups' heights
    function adjustAllGroupHeights() {
      document.querySelectorAll('.dropzone').forEach(group => {
        adjustGroupHeight(group);
      });
    }

    // Initial Felder dynamisch hinzufügen
    function renderGroups(preservedGroupItems = null) {
      const container = document.getElementById('container');
      // Save mapping from group id to its current items (by item id)
      let groupItems;
      if (preservedGroupItems) {
        groupItems = preservedGroupItems;
      } else {
        groupItems = {};
        Array.from(container.querySelectorAll('.dropzone')).forEach(zone => {
          const groupId = zone.id;
          groupItems[groupId] = [];
          Array.from(zone.querySelectorAll('.draggable')).forEach(item => {
            groupItems[groupId].push({
              id: item.id,
              rowIndex: item.parentElement.dataset.slotIndex || 0
            });
          });
        });
      }

      // Remove only dropzones, but NOT their children (items)
      Array.from(container.querySelectorAll('.dropzone')).forEach(zone => {
        // Move all draggable items to a temporary container to preserve them
        Array.from(zone.querySelectorAll('.draggable')).forEach(item => {
          document.getElementById('draggableContainer').appendChild(item);
        });
        container.removeChild(zone);
      });

      // Now re-add dropzones
      fieldConfig.forEach(field => {
        const dropzone = createDropzone(field);
        container.appendChild(dropzone);
      });

      // After all dropzones are created, re-attach items to their groups
      Object.entries(groupItems).forEach(([groupId, items]) => {
        const dropzone = document.getElementById(groupId);
        if (dropzone) {
          items.forEach(itemData => {
            const item = document.getElementById(itemData.id);
            if (item) {
              const rowIndex = itemData.rowIndex || 0;
              const rows = dropzone.querySelectorAll('.slot-row');
              if (rows[rowIndex]) {
                rows[rowIndex].innerHTML = '';
                rows[rowIndex].appendChild(item);
                rows[rowIndex].dataset.empty = 'false';
                rows[rowIndex].classList.add('filled');
              } else if (rows.length > 0) {
                // Find first available row if specific index not found
                const firstEmptyRow = Array.from(rows).find(r => r.dataset.empty === 'true');
                if (firstEmptyRow) {
                  firstEmptyRow.innerHTML = '';
                  firstEmptyRow.appendChild(item);
                  firstEmptyRow.dataset.empty = 'false';
                  firstEmptyRow.classList.add('filled');
                }
              }
            }
          });
        }
      });

      updateGroupSpaceInfo();
      updateAllCurrentItems();
      
      // Adjust the heights after items are placed
      adjustAllGroupHeights();
    }

    function renderDraggables() {
      const draggableContainer = document.getElementById('draggableContainer');
      draggableContainer.innerHTML = '';
      
      // Get the IDs of items already placed in groups
      const assignedItemIds = new Set();
      document.querySelectorAll('.dropzone .draggable').forEach(item => {
        assignedItemIds.add(item.id);
      });
      
      // Only render items that aren't already assigned to groups
      items.forEach(item => {
        // Skip if this item is already in a group
        if (assignedItemIds.has(item.id)) {
          return;
        }
        
        const draggable = document.createElement('div');
        draggable.classList.add('draggable');
        draggable.id = item.id;

        // Create a text span for the item's content
        const textSpan = document.createElement('span');
        textSpan.textContent = item.content;
        textSpan.style.pointerEvents = 'none';
        draggable.appendChild(textSpan);

        // Delete button for item with improved styling for touch targets
        const delBtn = document.createElement('button');
        delBtn.textContent = '✕';
        delBtn.title = 'Kind löschen';
        delBtn.style.marginLeft = '8px';
        delBtn.style.background = '#ff6666';
        delBtn.style.color = 'white';
        delBtn.style.border = 'none';
        delBtn.style.borderRadius = '4px';
        delBtn.style.cursor = 'pointer';
        delBtn.style.fontSize = '14px';
        delBtn.style.float = 'right';
        delBtn.style.position = 'relative';
        delBtn.style.top = '-2px';
        delBtn.style.padding = '2px 8px'; // Larger touch target
        delBtn.style.pointerEvents = 'auto'; // Ensure button receives events

        // Stop event propagation for all relevant events
        ['click', 'touchstart', 'touchmove', 'touchend'].forEach(eventType => {
          delBtn.addEventListener(eventType, (e) => {
            e.stopPropagation();
            if (eventType === 'click' || eventType === 'touchend') {
              e.preventDefault();

              // Handle removal from slots if needed
              const slotRow = draggable.closest('.slot-row');
              const dropzone = draggable.closest('.dropzone');

              if (slotRow && dropzone) {
                // Reset the slot row
                slotRow.innerHTML = '<td></td>';
                slotRow.dataset.empty = 'true';
                slotRow.classList.remove('filled');

                // Update the dropzone counter
                const currentItems = parseInt(dropzone.getAttribute('data-current-items')) - 1;
                dropzone.setAttribute('data-current-items', currentItems);
                updateCounter(dropzone);
              }

              deleteItem(item.id);
            }
          });
        });

        draggable.appendChild(delBtn);
        draggable.setAttribute('draggable', 'true');
        draggableContainer.appendChild(draggable);
      });
      setDraggableEvents();
    }

    function deleteItem(itemId) {
      // Find the item first to handle its container properly
      const itemElement = document.getElementById(itemId);

      if (itemElement) {
        // Check if item is in a slot row
        const slotRow = itemElement.closest('.slot-row');
        const dropzone = itemElement.closest('.dropzone');

        if (slotRow && dropzone) {
          // Reset the slot row
          slotRow.innerHTML = '<td></td>';
          slotRow.dataset.empty = 'true';
          slotRow.classList.remove('filled');

          // Update counter
          const currentItems = parseInt(dropzone.getAttribute('data-current-items')) - 1;
          dropzone.setAttribute('data-current-items', Math.max(0, currentItems));
          updateCounter(dropzone);
        }
      }

      // Remove from items array
      items = items.filter(i => i.id !== itemId);

      // Remove from DOM
      if (itemElement) {
        itemElement.remove();
      }

      updateGroupSpaceInfo();
    }

    function updateAllCurrentItems() {
      // For each dropzone, recount children that are .draggable
      document.querySelectorAll('.dropzone').forEach(zone => {
        const count = zone.querySelectorAll('.draggable').length;
        zone.setAttribute('data-current-items', count);
        updateCounter(zone);
      });
    }

    renderGroups();
    renderDraggables();
    adjustAllGroupHeights();

    // Add Group Button
    document.getElementById('btn_add_group').addEventListener('click', () => {
      // Store all existing items in their groups
      const draggables = {};
      document.querySelectorAll('.draggable').forEach(item => {
        draggables[item.id] = item.parentElement.id;
      });

      // Find next available id
      let idx = 1;
      while (fieldConfig.find(f => f.id === `zone${idx}`)) idx++;
      const newField = {
        id: `zone${idx}`,
        name: `Gruppe ${idx}`,
        maxItems: 1
      };
      fieldConfig.push(newField);

      // Add the new group without touching existing ones
      const container = document.getElementById('container');
      const newDropzone = createDropzone(newField);
      container.appendChild(newDropzone);
      
      // Update the counters and info
      updateAllCurrentItems();
      updateGroupSpaceInfo();
      adjustAllGroupHeights();
    });

    // Add Item Button
    function addItemFromInput() {
      const input = document.getElementById('new_item_name');
      let name = input.value.trim();
      if (!name) {
        alert('Bitte einen Namen eingeben.');
        return;
      }
      // Ensure unique id
      let idx = 1;
      let id;
      do {
        id = `item${items.length + idx}`;
        idx++;
      } while (items.find(i => i.id === id));
      items.push({ id, content: name });
      renderDraggables();
      updateGroupSpaceInfo();
      input.value = '';
    }

    document.getElementById('btn_add_item').addEventListener('click', addItemFromInput);

    document.getElementById('new_item_name').addEventListener('keydown', function(e) {
      if (e.key === 'Enter') {
        addItemFromInput();
      }
    });

    // Draggable Items dynamisch hinzufügen (handled by renderDraggables now)

    // Dragging Logik
    function setDraggableEvents() {
      const draggables = document.querySelectorAll('.draggable');
      draggables.forEach(draggable => {
        // Mouse drag events
        draggable.addEventListener('dragstart', () => {
          draggable.classList.add('dragging');
          
          // Update the row when dragging starts
          const parentRow = draggable.parentElement;
          if (parentRow && parentRow.classList.contains('slot-row')) {
            parentRow.dataset.dragging = 'true';
          }
        });
        
        draggable.addEventListener('dragend', () => {
          draggable.classList.remove('dragging');
          
          // Update the parent row when drag ends
          const parentRow = draggable.parentElement;
          if (parentRow) {
            if (parentRow.classList.contains('slot-row')) {
              parentRow.dataset.dragging = 'false';
            }
          }
          
          // Adjust heights of all groups after drag ends
          adjustAllGroupHeights();
        });

        // Add touch event support
        draggable.addEventListener('touchstart', handleTouchStart, { passive: false });
        draggable.addEventListener('touchmove', handleTouchMove, { passive: false });
        draggable.addEventListener('touchend', handleTouchEnd, { passive: false });
      });
    }

    // Touch event handling variables
    let touchDragging = false;
    let currentTouchElement = null;
    let touchOffsetX = 0;
    let touchOffsetY = 0;
    let originalPosition = { parent: null, nextSibling: null };
    
    // Handle touch start event
    function handleTouchStart(e) {
      e.preventDefault(); // Prevent scrolling when starting to drag
      
      const touch = e.touches[0];
      const draggable = e.currentTarget;
      
      // Store the element being touched
      currentTouchElement = draggable;
      
      // Calculate touch offset relative to the element
      const rect = draggable.getBoundingClientRect();
      touchOffsetX = touch.clientX - rect.left;
      touchOffsetY = touch.clientY - rect.top;
      
      // Store original position for potential cancel
      originalPosition = {
        parent: draggable.parentNode,
        nextSibling: draggable.nextElementSibling
      };
      
      // Apply dragging class and style
      draggable.classList.add('dragging');
      draggable.style.position = 'fixed';
      draggable.style.zIndex = '1000';
      draggable.style.opacity = '0.8';
      
      // Mark touch dragging as active
      touchDragging = true;
      
      // Update the row when dragging starts
      const parentRow = draggable.parentElement;
      if (parentRow && parentRow.classList.contains('slot-row')) {
        parentRow.dataset.dragging = 'true';
        parentRow.dataset.empty = 'true';
        parentRow.classList.remove('filled');
      }
      
      // Move element to document body for unrestricted movement
      document.body.appendChild(draggable);
      
      // Position at the touch point accounting for the offset
      positionElementAtTouch(touch, draggable);
    }

    // Position element at touch location accounting for offset
    function positionElementAtTouch(touch, element) {
      element.style.left = (touch.clientX - touchOffsetX) + 'px';
      element.style.top = (touch.clientY - touchOffsetY) + 'px';
    }
    
    // Handle touch move event
    function handleTouchMove(e) {
      e.preventDefault(); // Prevent scrolling during drag
      
      if (!touchDragging || !currentTouchElement) return;
      
      const touch = e.touches[0];
      
      // Move the element with the touch
      positionElementAtTouch(touch, currentTouchElement);
      
      // Find the element under the touch point for drop targeting
      const dropTarget = getTouchDropTarget(touch);
      
      // Reset hover state on all potential drop targets
      document.querySelectorAll('.slot-row').forEach(row => {
        row.classList.remove('hover');
      });
      
      // If over a valid drop target, highlight it
      if (dropTarget && dropTarget.classList.contains('slot-row') && dropTarget.dataset.empty === 'true') {
        dropTarget.classList.add('hover');
      }
    }
    
    // Find a drop target under the touch point
    function getTouchDropTarget(touch) {
      // Hide the dragged element temporarily to get accurate elementFromPoint
      if (currentTouchElement) {
        currentTouchElement.style.visibility = 'hidden';
      }
      
      // Get the element at touch position
      const element = document.elementFromPoint(touch.clientX, touch.clientY);
      
      // Make the dragged element visible again
      if (currentTouchElement) {
        currentTouchElement.style.visibility = 'visible';
      }
      
      // For slot rows, return the row itself
      if (element && element.classList && element.classList.contains('slot-row')) {
        return element;
      }
      
      // For cells inside rows, return the row
      if (element && element.tagName === 'TD') {
        return element.parentElement;
      }
      
      // For the draggable container, return it
      if (element && element.id === 'draggableContainer') {
        return element;
      }
      
      // For other elements, try to find a slot row or draggable container as parent
      let parent = element;
      while (parent) {
        if (parent.classList && parent.classList.contains('slot-row')) {
          return parent;
        }
        if (parent.id === 'draggableContainer') {
          return parent;
        }
        parent = parent.parentElement;
      }
      
      return null;
    }
    
    // Handle touch end event
    function handleTouchEnd(e) {
      e.preventDefault();
      
      if (!touchDragging || !currentTouchElement) return;
      
      // Find drop target at the last touch position
      const touch = e.changedTouches[0];
      const dropTarget = getTouchDropTarget(touch);
      
      // Reset element styles
      currentTouchElement.style.position = '';
      currentTouchElement.style.left = '';
      currentTouchElement.style.top = '';
      currentTouchElement.style.zIndex = '';
      currentTouchElement.style.opacity = '';
      currentTouchElement.classList.remove('dragging');
      
      // Handle drop based on target
      if (dropTarget) {
        if (dropTarget.classList.contains('slot-row') && dropTarget.dataset.empty === 'true') {
          // Drop into a slot row
          handleDropIntoSlotRow(dropTarget, currentTouchElement);
        } else if (dropTarget.id === 'draggableContainer') {
          // Drop back into the draggable container
          dropTarget.appendChild(currentTouchElement);
          
          // If it came from a slot row, update that row
          if (originalPosition.parent && originalPosition.parent.classList.contains('slot-row')) {
            updateSourceRowAfterDrag(originalPosition.parent);
          }
        } else {
          // Invalid drop target, return to original position
          returnToOriginalPosition();
        }
      } else {
        // No drop target found, return to original position
        returnToOriginalPosition();
      }
      
      // Reset hover state on all drop targets
      document.querySelectorAll('.slot-row').forEach(row => {
        row.classList.remove('hover');
      });
      
      // Reset touch tracking variables
      touchDragging = false;
      currentTouchElement = null;
      
      // Update counters and adjust heights
      updateAllCurrentItems();
      adjustAllGroupHeights();
    }
    
    // Handle dropping an element into a slot row
    function handleDropIntoSlotRow(row, element) {
      // Clear the row
      row.innerHTML = '';
      
      // Mark the row as filled
      row.dataset.empty = 'false';
      row.classList.add('filled');
      row.classList.remove('hover');
      
      // Add the item to the row
      row.appendChild(element);
      
      // If the element came from another slot row, update that row
      if (originalPosition.parent && originalPosition.parent.classList.contains('slot-row')) {
        updateSourceRowAfterDrag(originalPosition.parent);
      }
      
      // Update dropzone counter
      const dropzone = row.closest('.dropzone');
      if (dropzone) {
        const sourceZone = originalPosition.parent ? originalPosition.parent.closest('.dropzone') : null;
        
        // If moving from one zone to another, decrement source counter
        if (sourceZone && sourceZone !== dropzone) {
          const sourceItems = parseInt(sourceZone.getAttribute('data-current-items')) - 1;
          sourceZone.setAttribute('data-current-items', Math.max(0, sourceItems));
          updateCounter(sourceZone);
        }
        
        // Update target zone counter
        const currentItems = parseInt(dropzone.getAttribute('data-current-items')) + 1;
        dropzone.setAttribute('data-current-items', currentItems);
        updateCounter(dropzone);
      }
    }
    
    // Update a source row after an element has been dragged out
    function updateSourceRowAfterDrag(row) {
      if (!row) return;
      
      // Reset the source row
      row.innerHTML = '<td></td>';
      row.dataset.empty = 'true';
      row.classList.remove('filled');
      row.dataset.dragging = 'false';
    }
    
    // Return dragged element to its original position
    function returnToOriginalPosition() {
      if (!currentTouchElement) return;
      
      if (originalPosition.parent) {
        if (originalPosition.nextSibling) {
          originalPosition.parent.insertBefore(currentTouchElement, originalPosition.nextSibling);
        } else {
          originalPosition.parent.appendChild(currentTouchElement);
        }
        
        // If returning to a slot row, make sure it's marked as filled
        if (originalPosition.parent.classList.contains('slot-row')) {
          originalPosition.parent.dataset.empty = 'false';
          originalPosition.parent.classList.add('filled');
          originalPosition.parent.dataset.dragging = 'false';
        }
      } else {
        // If no original parent (shouldn't happen), add to unassigned area
        document.getElementById('draggableContainer').appendChild(currentTouchElement);
      }
    }

    // Rückgabe von Items in den ursprünglichen Bereich ermöglichen
    const draggableArea = document.getElementById('draggableContainer');
    draggableArea.addEventListener('dragover', (e) => {
      e.preventDefault();
    });

    draggableArea.addEventListener('drop', (e) => {
      e.preventDefault();
      const draggingItem = document.querySelector('.dragging');
      if (!draggingItem) return;
      
      const parentRow = draggingItem.parentElement;
      const currentZone = parentRow && parentRow.closest('.dropzone');
      
      if (currentZone && parentRow.classList.contains('slot-row')) {
        // Update row to show it's empty - without text
        parentRow.innerHTML = `<td></td>`;
        parentRow.dataset.empty = 'true';
        parentRow.classList.remove('filled');
        
        // Update zone counter
        const currentItems = parseInt(currentZone.getAttribute('data-current-items'));
        currentZone.setAttribute('data-current-items', currentItems - 1);
        updateCounter(currentZone);
      }
      
      draggableArea.appendChild(draggingItem);
      updateAllCurrentItems();
    });

    // Funktion zum Aktualisieren der Anzeige und der Slots
    function updateCounter(zone) {
      const currentItems = parseInt(zone.getAttribute('data-current-items'));
      const maxItems = parseInt(zone.getAttribute('data-max-items'));
      const counter = zone.querySelector('.counter');
      
      counter.textContent = `${currentItems} / ${maxItems}`;
      
      // Wenn das Feld voll ist, Hintergrundfarbe ändern
      if (currentItems >= maxItems) {
        zone.classList.add('full');
      } else {
        zone.classList.remove('full');
      }
    }

    // Anpassung für Reset: Nach renderGroups() und renderDraggables() aufrufen
    document.getElementById('btn_reset').addEventListener('click', () => {
      document.querySelectorAll('.draggable').forEach(item => {
        document.getElementById('draggableContainer').appendChild(item);
      });
      renderGroups();
      renderDraggables();
      updateAllCurrentItems();
      updateGroupSpaceInfo();
      adjustAllGroupHeights();
    });

    // Function to download data to a file
    function download(data, filename, type) {
      var file = new Blob([data], {type: type});
      if (window.navigator.msSaveOrOpenBlob) // IE10+
        window.navigator.msSaveOrOpenBlob(file, filename);
      else { // Others
        var a = document.createElement("a"),
                url = URL.createObjectURL(file);
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        setTimeout(function() {
          document.body.removeChild(a);
          window.URL.revokeObjectURL(url);
        }, 0);
      }
    }

    function getCurrentConfiguration() {
      const config = {};
      // For each dropzone (group)
      document.querySelectorAll('.dropzone').forEach(zone => {
        const groupName = zone.querySelector('.zone-title').textContent;
        config[groupName] = [];
        zone.querySelectorAll('.draggable').forEach(item => {
          // Remove delete button text
          let name = item.childNodes[0].nodeType === 3 ? item.childNodes[0].textContent.trim() : item.textContent.trim();
          if (name.endsWith('✕')) name = name.slice(0, -1).trim();
          config[groupName].push(name);
        });
      });
      // Unassigned items
      config['Unassigned'] = [];
      document.querySelectorAll('#draggableContainer .draggable').forEach(item => {
        let name = item.childNodes[0].nodeType === 3 ? item.childNodes[0].textContent.trim() : item.textContent.trim();
        if (name.endsWith('✕')) name = name.slice(0, -1).trim();
        config['Unassigned'].push(name);
      });

      // Add meta information about groups
      config['_meta'] = {
        groupCount: fieldConfig.length,
        groups: fieldConfig.map(f => ({
          id: f.id,
          name: f.name,
          size: f.maxItems
        }))
      };

      return config;
    }

    // Download as text
    document.getElementById('btn_download_text').addEventListener('click', () => {
      // Get current configuration
      const config = getCurrentConfiguration();
      let textOutput = '';

      // Format each group and its items
      Object.keys(config).forEach(groupName => {
        // Skip meta information and empty groups
        if (groupName === '_meta' || config[groupName].length === 0) return;

        // Add group name and its items
        textOutput += `${groupName}:\n\t${config[groupName].join('\n\t')}\n\n`;
      });

      // Download as text file
      download(textOutput, 'group_data.txt', 'text/plain');
    });

    // Load configuration from file
    document.getElementById('btn_load').addEventListener('click', () => {
      document.getElementById('configFile').click();
    });

    document.getElementById('configFile').addEventListener('change', function(event) {
      const file = event.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = function(e) {
        try {
          const config = JSON.parse(e.target.result);
          loadConfiguration(config);
        } catch (err) {
          alert('Invalid configuration file.');
        }
        event.target.value = '';
      };
      reader.readAsText(file);
    });

    function loadConfiguration(config) {
      // Rebuild items array from config
      let allNames = [];
      Object.keys(config).forEach(group => {
        if (group !== '_meta') {
          allNames = allNames.concat(config[group]);
        }
      });
      items = allNames
        .filter((name, idx, arr) => arr.indexOf(name) === idx)
        .map((name, idx) => ({ id: `item${idx + 1}`, content: name }));

      // Set fieldConfig to match loaded groups
      fieldConfig = [];
      if (config._meta && Array.isArray(config._meta.groups)) {
        // Use meta group info if present
        config._meta.groups.forEach(g => {
          fieldConfig.push({
            id: g.id,
            name: g.name,
            maxItems: g.size
          });
        });
      } else {
        // Fallback: infer from config
        Object.keys(config).forEach((group, idx) => {
          if (group === 'Unassigned' || group === '_meta') return;
          fieldConfig.push({
            id: `zone${idx + 1}`,
            name: group,
            maxItems: config[group].length > 0 ? config[group].length : 3
          });
        });
      }
      renderGroups();
      renderDraggables();

      // Assign items to groups
      if (config._meta && Array.isArray(config._meta.groups)) {
        config._meta.groups.forEach((g, idx) => {
          const zone = document.querySelectorAll('.dropzone')[idx];
          if (!zone) return;
          
          const rows = zone.querySelectorAll('.slot-row');
          let rowIndex = 0;
          
          if (config[g.name]) {
            config[g.name].forEach(name => {
              const item = Array.from(document.querySelectorAll('.draggable'))
                .find(d => d.childNodes[0].nodeType === 3
                  ? d.childNodes[0].textContent.trim() === name
                  : d.textContent.trim().replace('✕', '').trim() === name
                );
              
              if (item && rowIndex < rows.length) {
                // Clear the row first
                rows[rowIndex].innerHTML = '';
                
                // Add the item to the row
                rows[rowIndex].appendChild(item);
                rows[rowIndex].dataset.empty = 'false';
                rows[rowIndex].classList.add('filled');
                
                rowIndex++;
              }
            });
          }
          
          zone.setAttribute('data-current-items', rowIndex);
          updateCounter(zone);
        });
      } else {
        Object.keys(config).forEach((group, idx) => {
          if (group === 'Unassigned' || group === '_meta') return;
          
          const zone = document.querySelectorAll('.dropzone')[idx];
          if (!zone) return;
          
          const rows = zone.querySelectorAll('.slot-row');
          let rowIndex = 0;
          
          config[group].forEach(name => {
            const item = Array.from(document.querySelectorAll('.draggable'))
              .find(d => d.childNodes[0].nodeType === 3
                ? d.childNodes[0].textContent.trim() === name
                : d.textContent.trim().replace('✕', '').trim() === name
              );
            
            if (item && rowIndex < rows.length) {
              // Clear the row first
              rows[rowIndex].innerHTML = '';
              
              // Add the item to the row
              rows[rowIndex].appendChild(item);
              rows[rowIndex].dataset.empty = 'false';
              rows[rowIndex].classList.add('filled');
              
              rowIndex++;
            }
          });
          
          zone.setAttribute('data-current-items', rowIndex);
          updateCounter(zone);
        });
      }

      // Place remaining items in unassigned area
      if (config['Unassigned']) {
        config['Unassigned'].forEach(name => {
          const item = Array.from(document.querySelectorAll('.draggable'))
            .find(d => d.childNodes[0].nodeType === 3
              ? d.childNodes[0].textContent.trim() === name
              : d.textContent.trim().replace('✕', '').trim() === name
            );
          if (item) {
            document.getElementById('draggableContainer').appendChild(item);
          }
        });
      }
      
      updateAllCurrentItems();
      updateGroupSpaceInfo();
      
      // Adjust heights after loading configuration
      setTimeout(adjustAllGroupHeights, 50);
    }

    // Event Listener für den Download Button
    document.getElementById('btn_download').addEventListener('click', () => {
      const data = JSON.stringify(getCurrentConfiguration(), null, 2);
      download(data, 'group_data.json', 'application/json');
    });

    // Random distribute button - updated for table rows
    document.getElementById('btn_random_distribute').addEventListener('click', function() {
      // Gather all items (both assigned and unassigned)
      const allItems = [];
      
      // Collect items from all groups
      document.querySelectorAll('.dropzone .draggable').forEach(item => {
        allItems.push(item);
      });
      
      // Collect unassigned items
      document.querySelectorAll('#draggableContainer .draggable').forEach(item => {
        allItems.push(item);
      });
      
      // First, move all items to unassigned area
      allItems.forEach(item => {
        document.getElementById('draggableContainer').appendChild(item);
      });
      
      // Reset all rows to empty
      document.querySelectorAll('.slot-row').forEach(row => {
        row.innerHTML = `<td></td>`;  // Empty cell with no text
        row.dataset.empty = 'true';
        row.classList.remove('filled');
      });
      
      // Reset all dropzone counters
      document.querySelectorAll('.dropzone').forEach(zone => {
        zone.setAttribute('data-current-items', '0');
        updateCounter(zone);
      });
      
      // Shuffle the items
      for (let i = allItems.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [allItems[i], allItems[j]] = [allItems[j], allItems[i]];
      }
      
      // Get all empty rows from all groups
      const allRows = Array.from(document.querySelectorAll('.slot-row'));
      
      // Shuffle the rows order to randomize placement
      for (let i = allRows.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [allRows[i], allRows[j]] = [allRows[j], allRows[i]];
      }
      
      // Assign items to random rows until we run out of items or rows
      const itemsToAssign = Math.min(allItems.length, allRows.length);
      
      for (let i = 0; i < itemsToAssign; i++) {
        // Clear the row
        allRows[i].innerHTML = '';
        
        // Add item to row
        allRows[i].appendChild(allItems[i]);
        allRows[i].dataset.empty = 'false';
        allRows[i].classList.add('filled');
        
        // Update counter of parent dropzone
        const parentZone = allRows[i].closest('.dropzone');
        const currentItems = parseInt(parentZone.getAttribute('data-current-items')) + 1;
        parentZone.setAttribute('data-current-items', currentItems);
        updateCounter(parentZone);
      }
      
      // Update all counters and info
      updateAllCurrentItems();
      
      // Make sure to adjust heights with a slight delay to ensure DOM is updated
      setTimeout(adjustAllGroupHeights, 50);
    });

    // Create equal groups button - updated for table rows
    document.getElementById('btn_create_equal_groups').addEventListener('click', function() {
      const groupCount = parseInt(document.getElementById('group_count').value);
      
      if (isNaN(groupCount) || groupCount < 1) {
        alert('Bitte geben Sie eine positive Zahl ein.');
        return;
      }
      
      // Gather all items (both assigned and unassigned)
      const allItems = [];
      
      // Collect items from all groups
      document.querySelectorAll('.dropzone .draggable').forEach(item => {
        allItems.push(item);
      });
      
      // Collect unassigned items
      document.querySelectorAll('#draggableContainer .draggable').forEach(item => {
        allItems.push(item);
      });
      
      if (allItems.length === 0) {
        alert('Es gibt keine Elemente zum Verteilen.');
        return;
      }
      
      // Calculate exact group sizes to fit all items perfectly
      const baseSize = Math.floor(allItems.length / groupCount);
      const remainder = allItems.length % groupCount;
      
      // Clear current groups
      fieldConfig = [];
      
      // Create new groups with optimal sizes
      for (let i = 1; i <= groupCount; i++) {
        // Add one extra slot to some groups if we have a remainder
        const extraItem = i <= remainder ? 1 : 0;
        fieldConfig.push({
          id: `zone${i}`,
          name: `Gruppe ${i}`,
          maxItems: baseSize + extraItem
        });
      }
      
      // First, move all items to unassigned area
      allItems.forEach(item => {
        document.getElementById('draggableContainer').appendChild(item);
      });
      
      // Re-render the groups
      renderGroups();
      
      // Shuffle the items
      for (let i = allItems.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [allItems[i], allItems[j]] = [allItems[j], allItems[i]];
      }
      
      // Get all rows from newly created groups
      const allRows = Array.from(document.querySelectorAll('.slot-row'));
      
      // Distribute items to rows in order
      const itemsToAssign = Math.min(allItems.length, allRows.length);
      
      for (let i = 0; i < itemsToAssign; i++) {
        // Clear the row
        allRows[i].innerHTML = '';
        
        // Add item to row
        allRows[i].appendChild(allItems[i]);
        allRows[i].dataset.empty = 'false';
        allRows[i].classList.add('filled');
        
        // Update counter of parent dropzone
        const parentZone = allRows[i].closest('.dropzone');
        const currentItems = parseInt(parentZone.getAttribute('data-current-items')) + 1;
        parentZone.setAttribute('data-current-items', currentItems);
        updateCounter(parentZone);
      }
      
      // Update all counters and info
      updateAllCurrentItems();
      updateGroupSpaceInfo();
      
      // Make sure to adjust heights with a slight delay to ensure DOM is updated
      setTimeout(adjustAllGroupHeights, 50);
    });

    // Create groups of specific size button - updated for table rows
    document.getElementById('btn_create_size_groups').addEventListener('click', function() {
      const groupSize = parseInt(document.getElementById('group_count').value);
      
      if (isNaN(groupSize) || groupSize < 1) {
        alert('Bitte geben Sie eine positive Zahl ein.');
        return;
      }
      
      // Gather all items (both assigned and unassigned)
      const allItems = [];
      
      // Collect items from all groups
      document.querySelectorAll('.dropzone .draggable').forEach(item => {
        allItems.push(item);
      });
      
      // Collect unassigned items
      document.querySelectorAll('#draggableContainer .draggable').forEach(item => {
        allItems.push(item);
      });
      
      if (allItems.length === 0) {
        alert('Es gibt keine Elemente zum Verteilen.');
        return;
      }
      
      // Calculate how many groups we need
      const groupCount = Math.ceil(allItems.length / groupSize);
      
      // Clear current groups
      fieldConfig = [];
      
      // Create groups of requested size, last one might be smaller
      for (let i = 1; i <= groupCount; i++) {
        const isLastGroup = i === groupCount;
        const remainingItems = allItems.length - (i - 1) * groupSize;
        const thisGroupSize = isLastGroup ? Math.min(groupSize, remainingItems) : groupSize;
        
        fieldConfig.push({
          id: `zone${i}`,
          name: `Gruppe ${i}`,
          maxItems: thisGroupSize
        });
      }
      
      // First, move all items to unassigned area
      allItems.forEach(item => {
        document.getElementById('draggableContainer').appendChild(item);
      });
      
      // Re-render the groups
      renderGroups();
      
      // Shuffle the items
      for (let i = allItems.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [allItems[i], allItems[j]] = [allItems[j], allItems[i]];
      }
      
      // Get all rows from newly created groups
      const allRows = Array.from(document.querySelectorAll('.slot-row'));
      
      // Distribute items to rows in order
      const itemsToAssign = Math.min(allItems.length, allRows.length);
      
      for (let i = 0; i < itemsToAssign; i++) {
        // Clear the row
        allRows[i].innerHTML = '';
        
        // Add item to row
        allRows[i].appendChild(allItems[i]);
        allRows[i].dataset.empty = 'false';
        allRows[i].classList.add('filled');
        
        // Update counter of parent dropzone
        const parentZone = allRows[i].closest('.dropzone');
        const currentItems = parseInt(parentZone.getAttribute('data-current-items')) + 1;
        parentZone.setAttribute('data-current-items', currentItems);
        updateCounter(parentZone);
      }
      
      // Update all counters and info
      updateAllCurrentItems();
      updateGroupSpaceInfo();
      
      // Make sure to adjust heights with a slight delay to ensure DOM is updated
      setTimeout(adjustAllGroupHeights, 50);
    });

    // Add window resize event to readjust heights when window size changes
    window.addEventListener('resize', adjustAllGroupHeights);

  </script>
</body>
</html>
